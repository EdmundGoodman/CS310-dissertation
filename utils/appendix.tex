\appendix

\chapter{Project collateral}
\label{ch:project-collateral}

\section{Project Requirements}
\label{sec:project-requirements}

The specification document enumerated the set of MoSCoW prioritised \cite{CaseMethodFastTrack} requirements which unambiguously define the project scope. These requirements are replicated below:

% TODO: Uncomment when word count stops being tracked
% \begin{enumerate}
% \item
%   Select a target mini-app from ECP proxy applications or UK-MAC
%   (\textbf{Must have})
% \item
%   Fuzz test\footnote{an automated testing technique which uses boundary and erroneous test data as inputs, whilst monitoring for resultant undesired behaviour, originally proposed by Miller \textit{et al.} in 1990 \cite{millerEmpiricalStudyReliability1990}\cite{liangFuzzingStateArt2018}} the possible mini-apps for memory safety issues using static analysis tooling \cite{stepanovMemorySanitizerFastDetector2015}
%   (\textbf{Should have}, \textit{depends on 1})
% \item
%   Build tooling for running Rust unit tests on C++ code
%   (\textbf{Could have})
% \item
%   Write unit tests for the original C++ version of the
%   mini-app
%   (\textbf{Should have}, \textit{depends on 1, (3)})
% \item
%   Write direct translation of serial version mini-app from C++ to Rust
%   (\textbf{Must have}, \textit{depends on 1})
% \item
%   Modify serial version of translated code to be idiomatic Rust \cite{endlerMreIdiomaticrust2023} 
%   (\textbf{Should have}, \textit{depends on 5})
% \item
%   Equivalence check serial translated code by comparing results of end-to-end tests with original C++ code
%   (\textbf{Must have}, \textit{depends on 5}))
% \item
%   Equivalence check serial translated code by applying passing C++ unit tests to rust code
%   (\textbf{Must have}, \textit{depends on 4, 5})
% \item
%   Equivalence check serial translated code with limited formal verification techniques
%   (\textbf{Could have}, \textit{depends on 5})
% \item
%   Equivalence check serial translated code by comparing generated LLVM IR of the C++ and translated Rust versions
%   (\textbf{Could have}, \textit{depends on 5})
% \item
%   Modify the serial translated code to allow parallel execution
%   (\textbf{Must have}, \textit{depends on 5})
% \item
%   Equivalence check parallel translated code via all previous techniques
%   (\textbf{Must have}, \textit{depends on 7, 8, (9), (10), 11})
% \item
%   Carry out a performance analysis of the serial translated Rust code with the original C++ code
%   (\textbf{Must have}, \textit{depends on 5})
% \item
%   Carry out a performance analysis of the parallel translated Rust code with the original C++ code
%   (\textbf{Must have}, \textit{depends on 11})
% \item
%   Modify the parallel translated code to allow execution across clustered compute resources
%   (\textbf{Could have}, \textit{depends on 11})
% \item
%   Equivalence check clustered translated code via all previous techniques
%   (\textbf{Could have}, \textit{depends on 7, 8, (9), (10), 15})
% \item
%   Carry out a performance analysis of the clustered translated Rust code with the original C++ code
%   (\textbf{Could have}, \textit{depends on 15})
% \end{enumerate}

% \section{Mini-app selection}
% \label{sec:miniapp-selection}



\section{Mini-app selection process}
\label{sec:miniapp-selection}

A significant component of early project planning was selecting the mini-app to perform the translation on. Since the translation process would take a significant amount of time, and could be heavily impacted by the properties of the chosen mini-app, it was vital to make an informed selection. The selection process for the mini-app is described below, broadly replicated from the progress report document:

% TODO: Uncomment when word count stops being tracked
% The first objective set out in the specification was ``Select a target mini-app from ECP proxy applications or UK-MAC (\textbf{Must have})'', and all other objectives trivially have a dependency on it.

% % Criteria for selection
% Between the ECP Proxy Applications \cite{ECPProxyApplications} and UK-MAC \cite{UKMiniAppConsortium}, there were 91 possibilities from which to narrow down. The criteria for initial filtering of the mini-apps was:
% \begin{itemize}
%     \item The source code for the mini-app must be C++ only (no FORTRAN or Python), in order to conform to the project specification.
%     \item The mini-app must not use any High-Performance Computing frameworks, such as Kokkos \cite{KokkosEcosystem} or RAJA \cite{RAJAPortabilitySuite}. This is because they may not have Rust bindings, and the translation of a whole performance framework it out of scope for the project.
%     \item The source code for the mini-app must be available as a repository on GitHub, as access to the source code is necessary for the translation process.
% \end{itemize}

% % Script built for selection
% Due to the number of possible applications, a script was written to filter the applications by these criteria. First, the script makes a web request to the page for the application, for example \href{https://proxyapps.exascaleproject.org/app/minimd/}{miniMD}, and parses the unstructured HTML data from this website into a Polars DataFrame \cite{PolarsPolars2023}. If the application has a link to a GitHub repository, it also includes data from a request to the GitHub API \cite{GitHubRESTAPI}. Finally, it uses the scraped data to deselect mini-apps if they don't meet the criteria.

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.75\textwidth]{images/8_appendix/miniapp_sankey.png}
%     \caption{A Sankey Diagram showing the selection process for the mini-apps, generated by \href{https://sankeymatic.com/build/}{SankeyMatic}.}
%     \label{fig:miniapp_sankey}
% \end{figure}

% After the automated step of the selection process, six of the remaining thirty-six mini-apps were shortlisted, following a discussion with the project supervisor. These shortlisted mini-apps were then manually inspected for the criteria shown in Table \ref{table:miniapps}:

% \begin{table}[H]
% \centering
%     \caption{A table showing the shortlisted mini-apps and their aspects considered when making the final selection.
%     % The second column for codebase size was measured with the \texttt{sloccount}\cite{SLOCCount} tool, where smaller codebases are preferred. The third column indicates the presence of additional dependencies, which might not have Rust bindings so cannot be translated. The fourth column indicates what tests are provided, where more testing was preferred. The fifth column indicates whether different versions are provided for each implementation, which was also preferred. The final column indicates the presence of memory leaks as identified by the \texttt{valgrind}\cite{ValgrindHome} tool, which was again preferred, as it helps motivate the replacement process from C++ to Rust.
%     }
%     \label{table:miniapps}
%     \begin{tabular}{|p{0.14\linewidth}|p{0.125\linewidth}|p{0.12\linewidth}|p{0.1025\linewidth}|p{0.135\linewidth}|p{0.1\linewidth}|}
%     \hline
%     Name       & Codebase size (lines of code) & Additional dependencies & Tests               & Implemen-tation versions & Memory leaks \\ \hline\hline
%     CabanaPIC \cite{ECPcopaCabanaPIC2023} & \cellcolor{green!25}1792 & \cellcolor{red!25}Kokkos & \cellcolor{green!25}Unit and end-to-end & \cellcolor{orange!25}Kokkos only & \cellcolor{red!25}Untested     \\ \hline
%     CloverLeaf \cite{CloverLeaf} & \cellcolor{red!25}8045 & \cellcolor{green!25}None & \cellcolor{orange!25}End-to-end & \cellcolor{green!25}Many & \cellcolor{orange!25}None         \\ \hline
%     HPCCG \cite{herouxHPCCGSolverPackage2007} & \cellcolor{green!25}1542 & \cellcolor{green!25}None & \cellcolor{orange!25}End-to-end & \cellcolor{orange!25}OpenMP and MPI only & \cellcolor{green!25}375 kB       \\ \hline
%     MiniMD \cite{osti_1231191} & \cellcolor{orange!25}4082 & \cellcolor{green!25}None & \cellcolor{orange!25}End-to-end & \cellcolor{green!25}Many & \cellcolor{green!25}5.82 MB      \\ \hline
%     TeaLeaf \cite{TeaLeaf2023} & \cellcolor{orange!25}2580 & \cellcolor{green!25}None & \cellcolor{orange!25}End-to-end & \cellcolor{green!25}Many & \cellcolor{orange!25}None         \\ \hline
%     VPFFT++ \cite{VPFFT2023}   & \cellcolor{orange!25}3384 & \cellcolor{red!25}Eigen, FFTW & \cellcolor{orange!25}Unit & \cellcolor{orange!25}MPI only & \cellcolor{red!25}Untested     \\ \hline
%     % CabanaPIC \cite{ECPcopaCabanaPIC2023} & 1792 & Kokkos & Unit and end-to-end & Kokkos only & Untested \\ \hline
%     % CloverLeaf \cite{mallinson2013cloverleaf} & 8045 & None & End-to-end & Many & None \\ \hline
%     % HPCCG \cite{herouxHPCCGSolverPackage2007} & 1542 & None & End-to-end & OpenMP and MPI only & 375 kB \\ \hline
%     % MiniMD \cite{osti_1231191} & 4082 & None & End-to-end & Many & 5.82 MB \\ \hline
%     % TeaLeaf \cite{TeaLeaf2023} & 2580 & None & End-to-end & Many & None \\ \hline
%     % VPFFT++ \cite{VPFFT2023} & 3384 & Eigen, FFTW & Unit & MPI only & Untested \\ \hline
%     \end{tabular}
% \end{table}

% These mini-apps were manually inspected for the size and quality of their codebase (smaller and higher quality is better, assessed using the \texttt{sloccount} \cite{SLOCCount} and the \texttt{clang-tidy} linter \cite{ClangTidyExtraClang}), whether they had unit tests, whether they had multiple versions for serial/parallel, historical prominence, and whether they had any memory leaks using \texttt{valgrind} \cite{ValgrindHome}.

% \begin{figure}[H]
% \begin{verbatim}
% ==33790== 
% ==33790== HEAP SUMMARY:
% ==33790==     in use at exit: 5,875,096 bytes in 10 blocks
% ==33790==   total heap usage: 149 allocs, 139 frees, 6,348,737 bytes allocated
% ==33790== 
% [snip]
% ==33790== 
% ==33790== LEAK SUMMARY:
% ==33790==    definitely lost: 375,096 bytes in 4 blocks
% ==33790==    indirectly lost: 5,500,000 bytes in 6 blocks
% ==33790==      possibly lost: 0 bytes in 0 blocks
% ==33790==    still reachable: 0 bytes in 0 blocks
% ==33790==         suppressed: 0 bytes in 0 blocks
% ==33790== 
% ==33790== For lists of detected and suppressed errors, rerun with: -s
% ==33790== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
% \end{verbatim}
%     \caption{A snippet of the output of running \texttt{valgrind} on the HPCCG mini-app, with over 375kB directly lost over a test run with mesh size $25 \times 25 \times 25$.}
%     \label{fig:minimdValgrindOutput}
% \end{figure}

% Interestingly, some shortlisted mini-apps, including HPCCG, MiniMD, and TeaLeaf, leak memory -- as shown in the Figure \ref{fig:minimdValgrindOutput}. This is emblematic of one of the main drawbacks of C++ -- the ease with which it is to do manual memory management wrong. In contrast, Rust is designed to abstract away memory management from the programmer, instead focussing on the resultant properties of data ownership and lifetimes.

% After a manual comparison process on the aspects shown above, the decision was made to select the HPCCG mini-app for the translation process, due to its: small, high quality codebase and simple build system; absence of additional required dependencies; existing implementations for both OpenMP and MPI; and the presence of memory leaks.



\section{HPCCG matrix representation}
\label{sec:hpccg-matrix-representation}

To understand how HPCCG represents sparse matrices, consider the following example:
The following example describes how HPCCG uses a pointer-based variant of the compressed row storage format to represent sparse matrices.

% \begin{align}
%     \begin{pmatrix}
%         0 & 1 & 0 & 2 \\
%         0 & 0 & 5 & 0 \\
%         0 & 4 & 6 & 0 \\
%         3 & 0 & 0 & 0
%     \end{pmatrix}
%     \label{eq:exampleMatrix}
% \end{align}

% This sparse matrix can then be represented as two nested lists -- one containing the non-zero values in each row, and the other the indices of those non-zero values in that row. This means the sparse matrix in (\ref{eq:exampleMatrix}) can be written as:

% \begin{lstlisting}
% list_of_vals = [   [1, 2]  ,  [5]  ,  [4, 6]  ,  [3]   ]
% list_of_inds = [   [1, 3]  ,  [2]  ,  [1, 2]  ,  [0]   ]
% \end{lstlisting}

% This structure uses much less memory, but has the drawback that the inner lists for each row are of variable length, making the outer list non-homogenous. HPCCG's data structure is a flattening of the above structure to use single-dimensional arrays rather than nested ones for \texttt{list\_of\_vals} and \texttt{list\_of\_inds}. This then requires a mechanism to distinguish rows, so it uses auxiliary data structures for the lengths of each row (an array of integers called \texttt{nnz\_in\_row}), along with pointers to the start of each row in the values and indices arrays (two arrays of pointers called \texttt{ptr\_to\_vals\_in\_row} and \texttt{ptr\_to\_inds\_in\_row} respectively). Finally, the number of rows (an integer called \texttt{total\_nrow}) is also needed. Hence, HPCCG would represent the sparse matrix in (\ref{eq:exampleMatrix}) as follows:

% \begin{lstlisting}
% total_nrow          = 4
% nnz_in_row          = [ 2 ,     1 , 2 ,     1 ]
% list_of_vals        = [ 1 , 2 , 5 , 4 , 6 , 3 ]
% ptr_to_vals_in_row  = [ $\uparrow$ ,      $\uparrow$ ,  $\uparrow$,       $\uparrow$ ]
% list_of_inds        = [ 1 , 3 , 2 , 1 , 2 , 0 ]
% ptr_to_inds_in_row  = [ $\uparrow$ ,      $\uparrow$ ,  $\uparrow$,       $\uparrow$ ]
% \end{lstlisting}

% To traverse the values in a row $i$ of this data structure, first retrieve the pointer to the starting point in the list of values from \texttt{ptr\_to\_vals\_in\_row[i]}. Then, traverse through the list of values for the number of non-zeroes, \texttt{nnz\_in\_row[i]}. This same process applies to traversing indices in a row.

% This data structure provides significant performance improvements over a full matrix representation for the sparse matrix-vector multiplication operation. This is because it minimises both the memory bandwidth and arithmetic operations required, by omitting the zero-values which would not contribute to the product.